#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <string>
#include <deque>
#include "token.h"
#include "node.h"
#include "main.h"

static int n = 0;
static int m = 0;
char * templ = (char *) malloc(sizeof(char) * 4);
using namespace std;


/* perform left to right traversal, and perform different actions depending on subtree and node visited */
void codeGen(node_t *node)
{
	
	if (node->label == programN)
	{
		if (node->child[0] != NULL)
			codeGen(node->child[0]);

		codeGen(node->child[1]);

		fprintf(fout, "STOP\nOUT 0\n");
		for (int i = 0; i < n; i++)
			fprintf(fout, "T%d 0\n", i);
		return;
	}
	else if (node->label == varsN)
	{
		fprintf(fout, "LOAD %s\n", node->token[1].inst);
		fprintf(fout, "STORE %s\n", node->token[0].inst);
		if (node->child[0] != NULL)
			codeGen(node->child[0]);
		return;
	}
	else if (node->label == exprN)
	{
		if (node->child[1] != NULL)
		{
			codeGen(node->child[1]);
			char tn[4];
			sprintf(tn, "T%d", n++);
			fprintf(fout, "STORE %s\n", tn);
			codeGen(node->child[0]);
			if (node->token[0].type == DIVtk)
				fprintf(fout, "DIV %s\n", tn);
			else
				fprintf(fout, "MULT %s\n", tn);
		}
		else
			codeGen(node->child[0]);
		return;
	}
	else if (node->label == AN)
	{
		if (node->child[1] != NULL)
		{
			codeGen(node->child[1]);
			char tn[4];
			sprintf(tn, "T%d", n++);
			fprintf(fout, "STORE %s\n", tn);
			codeGen(node->child[0]);
			if (node->token[0].type == PLUStk)
				fprintf(fout, "ADD %s\n", tn);
			else
				fprintf(fout, "SUB %s\n", tn);
		}
		else
			codeGen(node->child[0]);
		return;
	}
	else if (node->label == MN)
	{
		codeGen(node->child[0]);
		if (node->token[0].type == MINtk)
			fprintf(fout, "MULT -1\n");
		return;
	}
	else if (node->label == RN)
	{
		if (node->child[0] == NULL)
			fprintf(fout, "LOAD %s\n", node->token[0].inst);
		else
			codeGen(node->child[0]);
		return;
	}
	else if (node->label == inN)
	{
		fprintf(fout, "READ %s\n", node->token[0].inst);
		return;
	}
	else if (node->label == outN)
	{
		codeGen(node->child[0]);
		fprintf(fout, "STORE OUT\n", 0);
		fprintf(fout, "WRITE OUT\n", 0);
		return;
	}
	else if (node->label == ifN)
	{
		// process 2nd <expr>
		codeGen(node->child[2]);
		char tn[4];
		sprintf(tn, "T%d", n++);
		fprintf(fout, "STORE %s\n", tn);

		// process 1st <expr>
		codeGen(node->child[0]);
		fprintf(fout, "SUB %s\n", tn);

		// create label to branch to
		char lm[4];
		sprintf(lm, "L%d", m++);
		strcpy(templ, lm);

		// logic string generated by <RO>
		codeGen(node->child[1]);

		// <stats> to process if true
		codeGen(node->child[3]);
		fprintf(fout, "%s: NOOP\n", lm);
		return;

	}
	else if (node->label == loopN)
	{
		// label begining of loop
		char lm1[4];
		sprintf(lm1, "L%d", m++);
		fprintf(fout, "%s: NOOP\n", lm1);

		// process 2nd <expr>
		codeGen(node->child[2]);
		char tn[4];
		sprintf(tn, "T%d", n++);
		fprintf(fout, "STORE %s\n", tn);

		// process 1st <expr>
		codeGen(node->child[0]);
		fprintf(fout, "SUB %s\n", tn);

		// create label to branch to
		char lm2[4];
		sprintf(lm2, "L%d", m++);
		strcpy(templ, lm2);

		// logic string generated by <RO>
		codeGen(node->child[1]);

		// <stats> to process if true
		codeGen(node->child[3]);
		fprintf(fout, "BR %s\n%s: NOOP\n", lm1, lm2);
		return;

	}
	else if (node->label == assignN)
	{
		codeGen(node->child[0]);
		fprintf(fout, "STORE %s\n", node->token[0].inst);
		return;
	}
	else if (node->label == RON)
	{
		if (node->token[0].type == LSTtk)
		{
			if (node->token[1].type == EQUtk)
				fprintf(fout, "BRPOS %s\n", templ);
			else
				fprintf(fout, "BRZPOS %s\n", templ);
		}
		else if (node->token[0].type == GRTtk)
		{
			if (node->token[1].type == EQUtk)
				fprintf(fout, "BRNEG %s\n", templ);
			else
				fprintf(fout, "BRZNEG %s\n", templ);
		}
		else if (node->token[0].type == EQUtk)
		{
			if (node->token[1].type == EQUtk)
				fprintf(fout, "BRZERO %s\n", templ);
			else
				fprintf(fout, "BRPOS %s\nBRNEG %s\n", templ, templ);
		}
		return;
	}
	else
	{
		// traverse child nodes
		for (int i = 0; i < 4; i++)
			if (node->child[i] != NULL)
				codeGen(node->child[i]);
		return;
	}
}
